//go:build exclude

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

#include <stdbool.h>

// "Dirty" syscalls
#define N_MMAP 9
#define N_MUNMAP 11
#define N_MREMAP 25
#define N_BRK 12

#define MAX_RINGBUF_ENTRIES 4096 * 1024  // must be a multiple of 4096

/* todo: figure out a way to have this autogenerated in go frontend*/
#define N_FAILURE_TYPES 3

enum failure_type {
    RINGBUF_FULL,
    GET_PARENT_FAILED,
    GET_PT_REGS_FAILED,
};


struct sc_event {
    pid_t pid;  // userland tgid
    pid_t ppid; // userland ptgid
    u64 timestamp;
    u64 syscall_nr;
    u64 pc;
    bool dirty;
};

struct sc_event *unused_sc_event __attribute__((unused));
enum failure_type *unused_failure_type __attribute__((unused));

/* follow_pid_map needs to be configured in userspace with the calling process's PID */
struct {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(key_size, sizeof(pid_t));
	__uint(value_size, sizeof(bool));
	__uint(max_entries, 65535);
	__uint(map_flags, 0);
} follow_pid_map SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, MAX_RINGBUF_ENTRIES);
} sc_events_map SEC(".maps");


/* err_map needs to be configured in userspace, with all counts set to 0 */
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(key_size, sizeof(int32));
    __uint(value_size, sizeof(u64));
    __uint(max_entries, N_FAILURE_TYPES);
    __uint(map_flags, 0);
} err_map SEC(".maps");


__always_inline void log_failure(enum failure_type failure) {
    u64 *p_count = bpf_map_lookup_elem(&err_map, &failure);
    if (!p_count)
        return;

    __sync_fetch_and_add(p_count, 1);
}


SEC("raw_tp/sys_enter")
int raw_tp_sys_enter(struct bpf_raw_tracepoint_args *ctx) {
    
    pid_t parent_tgid;
    pid_t calling_tgid;
    unsigned long syscall_nr;
    u64 timestamp;

    struct task_struct *task;
    struct task_struct *parent_task;
    
    volatile struct pt_regs *regs;
    struct sc_event *e;

    const bool tr = true;
    const bool fs = false;

    task = (struct task_struct *)bpf_get_current_task();
    if (!task)
        return 0;

    bpf_probe_read(&parent_task, sizeof(parent_task), &task->real_parent);
    if (!parent_task) {
        log_failure(GET_PARENT_FAILED);
        return 1;
    }

    bpf_probe_read(&parent_tgid, sizeof(parent_tgid), &parent_task->tgid);

    bool follow = bpf_map_lookup_elem(&follow_pid_map, &parent_tgid);
    if (!follow)
        return 0;
   
    calling_tgid = bpf_get_current_pid_tgid() & 0xFFFFFFFF;
    bpf_map_update_elem(&follow_pid_map, &calling_tgid, &tr, 0);

    regs = (struct pt_regs*)ctx->args[0];
    if (!regs) {
        log_failure(GET_PT_REGS_FAILED);
        return 1;
    }
    
    e = bpf_ringbuf_reserve(&sc_events_map, sizeof(struct sc_event), 0);

    if (!e) {
        log_failure(RINGBUF_FULL);
        return 1;
    }
        
    timestamp = bpf_ktime_get_ns();
    syscall_nr = ctx->args[1];

    e->pid = calling_tgid;
    e->ppid = parent_tgid;
    e->timestamp = timestamp;
    e->syscall_nr = syscall_nr;
    e->dirty = (syscall_nr == N_MMAP) || (syscall_nr == N_MUNMAP) || (syscall_nr == N_MREMAP) || (syscall_nr == N_BRK);

    u64 ip;
    bpf_probe_read(&ip, sizeof(ip), &regs->ip);
    
    e->pc = ip;

    bpf_ringbuf_submit(e, 0);

    return 0;
}


char LICENSE[] SEC("license") = "GPL";
