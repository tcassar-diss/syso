// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package syso

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type sysoFailureType uint32

const (
	sysoFailureTypeRINGBUF_FULL       sysoFailureType = 0
	sysoFailureTypeGET_PARENT_FAILED  sysoFailureType = 1
	sysoFailureTypeGET_PT_REGS_FAILED sysoFailureType = 2
	sysoFailureTypeALWAYS             sysoFailureType = 3
)

type sysoScEvent struct {
	Pid        int32
	Ppid       int32
	Timestamp  uint64
	SyscallNr  uint64
	Pc         uint64
	Stacktrace sysoStackTraceT
	Dirty      bool
	_          [7]byte
}

type sysoStackTraceT struct {
	UserStackSize        int32
	UserStackBuildidSize int32
	UserStack            [256]uint64
	UserStackBuildid     [256]struct {
		Status  int32
		BuildId [20]uint8
		Offset  uint64
	}
}

// loadSyso returns the embedded CollectionSpec for syso.
func loadSyso() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_SysoBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load syso: %w", err)
	}

	return spec, err
}

// loadSysoObjects loads syso and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*sysoObjects
//	*sysoPrograms
//	*sysoMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadSysoObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadSyso()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// sysoSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type sysoSpecs struct {
	sysoProgramSpecs
	sysoMapSpecs
}

// sysoSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type sysoProgramSpecs struct {
	RawTpSysEnter *ebpf.ProgramSpec `ebpf:"raw_tp_sys_enter"`
}

// sysoMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type sysoMapSpecs struct {
	ErrMap       *ebpf.MapSpec `ebpf:"err_map"`
	FollowPidMap *ebpf.MapSpec `ebpf:"follow_pid_map"`
	ScEventsMap  *ebpf.MapSpec `ebpf:"sc_events_map"`
}

// sysoObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadSysoObjects or ebpf.CollectionSpec.LoadAndAssign.
type sysoObjects struct {
	sysoPrograms
	sysoMaps
}

func (o *sysoObjects) Close() error {
	return _SysoClose(
		&o.sysoPrograms,
		&o.sysoMaps,
	)
}

// sysoMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadSysoObjects or ebpf.CollectionSpec.LoadAndAssign.
type sysoMaps struct {
	ErrMap       *ebpf.Map `ebpf:"err_map"`
	FollowPidMap *ebpf.Map `ebpf:"follow_pid_map"`
	ScEventsMap  *ebpf.Map `ebpf:"sc_events_map"`
}

func (m *sysoMaps) Close() error {
	return _SysoClose(
		m.ErrMap,
		m.FollowPidMap,
		m.ScEventsMap,
	)
}

// sysoPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadSysoObjects or ebpf.CollectionSpec.LoadAndAssign.
type sysoPrograms struct {
	RawTpSysEnter *ebpf.Program `ebpf:"raw_tp_sys_enter"`
}

func (p *sysoPrograms) Close() error {
	return _SysoClose(
		p.RawTpSysEnter,
	)
}

func _SysoClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed syso_x86_bpfel.o
var _SysoBytes []byte
